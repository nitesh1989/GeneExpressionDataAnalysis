library(reshape)
library(ggplot2)
################################################################################
# Collect pathways in a format for barplots
################################################################################
collect.pathways = function(status,path) {
files = list.files(path,full.names=T,pattern = ".csv")
new_df = data.frame()
for (i in 1:length(files)) {
x = read.csv(files[i])
pathwayName = gsub(pattern = paste0("_",status,".csv"),replacement="",x=(gsub(".+/","",files[i])))
# CHANGE HERE TO 7:22 for original TSS peak files
x = x[,c(4:7,1:3,7:20)]
knock_df = data.frame(x,pathway = pathwayName,pathwayGene = paste0(x$name,"-",pathwayName))
new_df = rbind(new_df,knock_df)
}
if("L" %in% colnames(new_df)){
new_df = new_df[new_df$L>3,]
}
return(new_df)
}
collect.pathways.charm = function(status,path) {
files = list.files(path,full.names=T,pattern = ".csv")
new_df = data.frame()
for (i in 1:length(files)) {
x = read.csv(files[i])
pathwayName = gsub(pattern = paste0("_",status,".csv"),replacement="",x=(gsub(".+/","",files[i])))
# CHANGE HERE TO 7:22 for original TSS peak files
#             x = x[,c(4:7,1:3,7:20)]
knock_df = data.frame(x,pathway = pathwayName,pathwayGene = paste0(x$name,"-",pathwayName))
new_df = rbind(new_df,knock_df)
}
return(new_df)
}
################################################################################
# Unlist the frequency of tables
################################################################################
unlist.frequency = function(df) {
x = which(df$Freq >= 1)
n.df = data.frame()
for (i in x){
i
freq = as.numeric(df$Freq[i])
c.df = data.frame(Pathway = rep(df$Pathway[i],times=freq),Freq = rep(1,times = freq),Gene = rep(df$Gene[i],times = freq))
n.df = rbind(n.df,c.df)
}
df = df[-(x),]
df = rbind(df,n.df)
return(df)
}
################################################################################
# Make bar plots for pathways
################################################################################
make.plot = function(collected.pathway,plotTitle){
data = as.data.frame(table(collected.pathway$name,collected.pathway$pathway))
data = cast(data=data,Var2~Var1)
dat.lng = melt(data=data,value.name=pathways)
dat.lng = dat.lng[dat.lng$value!=0,]
row.names(dat.lng) = NULL
colnames(dat.lng) = c("Pathway","Freq","Gene")
# Custom function to unlist the frequency tables
dat.lng = unlist.frequency(dat.lng)
p = ggplot(dat.lng,aes(Pathway,fill =Gene)) + geom_bar(position = "stack",color = "black",width=.5) + coord_flip()
p + ggtitle(plotTitle) +  guides(fill=guide_legend(ncol=4)) + scale_fill_discrete("Genes")
}
luad = collect.pathways(status = "LUAD",path = "~/TestRun/TCGA_Data_Analysis/TCGA-Analysed-After-Jan302014/LUAD/pathways")
luad = collect.pathways(status = "LUAD",path = "~/Documents/TestRun/TCGA_Data_Analysis/TCGA-Analysed-After-Jan302014/LUAD/pathways")
luad = luad[,c("name","description","pathway")]
make.plot(luad,"Lung Cancer Adenocarcinoma pathway-gene frequency barplot")
ggsave(file = "~/Documents/TestRun/TCGA_Data_Analysis/Reports/TexFiles/Cancer_template/LUAD_barplot.png",width = 25,height = 15)
ls
library(BiocInstaller)
biocLite("affy")
getwd()
###################################################
### Setting the working directory, in my case
setwd("~/Documents/GitHub/GeneExpressionDataAnalysis/affyData/")
###################################################
###Check the data
date()
###################################################
### Clear the workspace, note the two "embedded" function
rm(list=ls())
###################################################
### Load libraries needed for the analysis
require(affy)
require(hgu95a.db)
###################################################
### Load data previously save
load("./objs/affyData.rda")
###################################################
### The workspace content
ls()
###################################################
### Check classes
class(dat)
class(dat.rma)
###################################################
### Slots/elements contained in the two classes can be seen using:
### NOTE: SLOT NAMES USUALLY WORK AS ACCESSORS
slotNames(dat)
slotNames(dat.rma)
### This extract normalized and summarized gene expression
dat.expr <- exprs(dat.rma)
dim(dat.expr)
### This extract phenotypic information
pData(dat.rma)
### This extract features information
annotation(dat.rma)
### This extract perfect match probe intensities
dat.pm <- pm(dat)
dim(dat.pm)
### This extract mismatch probe intensities
dat.mm <- mm(dat)
dim(dat.mm)
mypar <- function (nRow = 1, nCol = 1, ptsExp = 1) {
par(mar = c(2, 2, 2, 1))
par(oma = c(2, 1, 1, 1))
par(mfrow = c(nRow, nCol))
par(cex = ptsExp)
}
nc <- ceiling(sqrt(ncol(dat.rma)))
nr <- ceiling(ncol(dat.rma)/nc)
mypar(nr,nc,0.5)
MAplot(dat[,],pairs=F,plot.method="smoothScatter")
mypar(nr,nc,0.5)
par(oma=c(2,1,1,1))
MAplot(dat[,],pairs=F,plot.method="smoothScatter")
mypar(nr,nc,0.5)
par(oma=c(2,1,1,1))
a <- exprs(dat.rma)
for (i in 1:ncol(a)){
ma.plot(A=((a[,i]+apply(a,1,median))/2),
M=(a[,i]-apply(a,1,median)),
show.statistics=TRUE,cex.main=1,
span=1/3, family.loess="gaussian", cex = 0.75,
plot.method="smoothScatter",add.loess = TRUE,
lwd = 2, lty = 2, loess.col = "red",ylim=c(-6,6),
main=paste(colnames(a)[i],
'\n vs pseudo-median reference chip'))
}
###################################################
getwd()
### Setting the working directory, in my case
###################################################
date()
### Clear the workspace, note the two "embedded" function
###################################################
require(limma)
require(hgu95a.db)
require(affy)
require(annotate)
###################################################
### Load  gene expression
load("objs/affyData.rda")
### Load  linear model results
load("objs/linearModel.rda")
###################################################
### Lets create the Functional Gene Set (FGS) list
### We will get the data from the annotation medata package hgu95a.db
### Use the package name as a function for listing the annotation content
hgu95a()
### Each environment in a metadata package maps identifiers to annotation information
### The annotation information can be gene/identifiers centered, or annotation centered:
### for example "ID -> SYMBOL" is gene centered,
### while "PATHID -> genes" is annotation centered
##################################################
### we need the second type of mapping: one FGS to all the genes of the FGS
### This extract mapping between kegg and affy identifiers for this platform
kegg <- as.list(hgu95aPATH2PROBE)
##################################################
### This for GENE ONTOLOGY
go <- as.list(hgu95aGO2ALLPROBES)
##################################################
### The code above created a list where each element has name
### (the kegg identifiers) and contains a vector of identifiers, see below
length(kegg)
##################################################
### To run a Wilcoxon rank-sum test we can use the geneSetTest() function in limma
### we need to identify the genes in the FGS, and give also a ranking statistics.
str(head(kegg))
###################################################
### Load libraries needed for the analysis
### Getting  the working directory, in my case
### Check the data
###################################################
rm(list=ls())
setwd("~/Documents/GitHub/GeneExpressionDataAnalysis/affyData/")
### To this end we will use the t-statistics obtained using the topTable() function
### The test on the fisrt FGS: default parameters
geneSetTest(tG2$ID%in%kegg[[1]],tG2$t)
### The test on the fisrt FGS: shift toward down-reguated genes
geneSetTest(tG2$ID%in%kegg[[1]],tG2$t,alternative="down")
### The test on the fisrt FGS: shift toward up-reguated genes
geneSetTest(tG2$ID%in%kegg[[1]],tG2$t,alternative="up")
load("./objs/affyData.rda")
### Load  linear model results
load("./objs/linearModel.rda")
length(kegg)
str(head(kegg))
###################################################
### We will get the data from the annotation medata package hgu95a.db
### Use the package name as a function for listing the annotation content
### The annotation information can be gene/identifiers centered, or annotation centered:
### for example "ID -> SYMBOL" is gene centered,
### while "PATHID -> genes" is annotation centered
### we need the second type of mapping: one FGS to all the genes of the FGS
##################################################
### Each environment in a metadata package maps identifiers to annotation information
### Lets create the Functional Gene Set (FGS) list
hgu95a()
### This extract mapping between kegg and affy identifiers for this platform
kegg <- as.list(hgu95aPATH2PROBE)
##################################################
### This for GENE ONTOLOGY
go <- as.list(hgu95aGO2ALLPROBES)
##################################################
### The code above created a list where each element has name
### (the kegg identifiers) and contains a vector of identifiers, see below
length(kegg)
str(head(kegg))
##################################################
### To run a Wilcoxon rank-sum test we can use the geneSetTest() function in limma
### we need to identify the genes in the FGS, and give also a ranking statistics.
### To this end we will use the t-statistics obtained using the topTable() function
### The test on the fisrt FGS: default parameters
### The test on the fisrt FGS: shift toward down-reguated genes
### The test on the fisrt FGS: shift toward up-reguated genes
### Visual representation
### The test on all KEGG  FGS (after removing NA
barcodeplot(tG2$ID%in%kegg[[1]],tG2$t)
geneSetTest(tG2$ID%in%kegg[[1]],tG2$t)
geneSetTest(tG2$ID%in%kegg[[1]],tG2$t,alternative="up")
geneSetTest(tG2$ID%in%kegg[[1]],tG2$t,alternative="down")
barcodeplot(tG2$t,tG2$ID%in%kegg[[1]])
kegg2 <- kegg[!is.na(kegg)]
gse <- vector()
for (i in 1:length(kegg2)){
gse[i] <- geneSetTest(tG2$ID%in%kegg2[[i]],tG2$t)
names(gse)[i] <- names(kegg2)[i]
}
tmp <- sapply(kegg2, function(gs, stat, ids) {
geneSetTest(ids%in%gs,stat)
}, stat=tG2$t, ids=tG2$ID)
str(gse)
head(gse)
### The test on all KEGG  FGS (we can also test for NA inside the loop)
gse <- vector()
for (i in 1:length(kegg)){
if (all(!tG2$ID%in%kegg[[i]])) {
gse[i] <- NA
}else{
gse[i] <- geneSetTest(tG2$ID%in%kegg[[i]],tG2$t)
}
names(gse)[i] <- names(kegg)[i]
}
### Check how the gse vector
length(gse)
str(gse)
### This is the way we can visualize this: the first gene set
i=10
barcodeplot(tG2$ID%in%kegg[[i]],tG2$t)
barcodeplot(tG2$t,tG2$ID%in%kegg[[i]])
i=which.min(gse)
barcodeplot(tG2$t,tG2$ID%in%kegg[[i]])
i=which.max(gse)
barcodeplot(tG2$t,tG2$ID%in%kegg[[i]])
?geneSetTest
args(geneSetTest)
geneSetTest(tG2$ID%in%kegg[[1]],tG2$t,alternative="up",type="t",
ranks.only=FALSE,nsim=1000)
geneSetTest(tG2$ID%in%kegg[[94]],tG2$t,alternative="down",type="t",
ranks.only=FALSE,nsim=1000)
##################################################
### limma enables you to run also self-contained tests as opposed to competitive tests
### To do this you can use the roast() function
### Extract the expression values
mat <- exprs(dat.rma)
### Select gene expression for the genes in the FGS
sel <- rownames(mat)%in%kegg[[1]]
##################################################
### For this analysis the design matrix must already account for the contrasts
newDmat <- data.frame(
Intercept=1,
CellType=dMat2[,1]+dMat2[,2] + (-1* (dMat2[,3]+dMat2[,4]))
)
roast(index= sel, y=mat, design=newDmat, contrast=2)
roast( y=mat,index= sel, design=newDmat, contrast=2)
gse2 <- list()
for (i in 1:5){
sel <- rownames(mat)%in%kegg[[i]]
gse2[[i]] <- roast( mat,sel, design=newDmat, contrast=2)
names(gse2)[i] <- names(kegg)[i]
}
gse.go <- list()
for (i in 1:5){
sel <- rownames(mat)%in%go[[i]]
gse.go[[i]] <- roast(mat,sel, design=newDmat, contrast=2)
names(gse.go)[i] <- names(go)[i]
}
library(KEGG.db)
library(GO.db)
require(limma)
require(affy)
require(hgu95a.db)
require(annotate)
###################################################
library(KEGG.db)
library(GO.db)
biocLite("KEGG.db")
biocLite("GO.db")
library(KEGG.db)
library(GO.db)
### If you do not have it install it from bioconductor
source("http://bioconductor.org/biocLite.R")
biocLite("KEGG.db")
### Check the content of the KEGG metadata package
KEGG()
GO()
### It appears that KEGGPATHID2NAME contains what we want
### so you can use mget() to obtain the patways names
pathNames <- mget(names(gse), KEGGPATHID2NAME, ifnotfound=NA)
goNames <- mget(names(gse.go),GOTERM,ifnotfound=NA)
goNames <- lapply(goNames,Term)
### Here we go
print(pathNames)
### Here we go
print(goNames)
### Retrieve the smallest p-values
pathNames[names(pathNames)==names(gse[which.min(gse)])]
### If they are in the same order
pathNames[which.min(gse)]
### Retrieve the smallest p-values
pathNames2 <- pathNames[length(pathNames):1]
### Always correct also if not in the same order
pathNames2[names(pathNames2)==names(gse[which.min(gse)])]
### Wrong if they are in the same order
pathNames2[which.min(gse)]
### Retrieve fgs with p-value less than 0.001
pathNames[gse<1e-5]
### Common genes
index <- which(gse<1e-2)
myFGS <- kegg[index]
sum(myFGS[[1]]%in%myFGS[[2]])
### Cross tabulation
all <- unique(unlist(myFGS))
table(fgs1=all%in%myFGS[[1]],fgs2=all%in%myFGS[[2]])
### Venn diagram
vennDiagram(data.frame(fgs1=all%in%myFGS[[1]],
fgs2=all%in%myFGS[[2]],fgs3=all%in%myFGS[[3]]))
#### Multiple testing correction
library(multtest)
### Correct p-values
adjp <- mt.rawp2adjp(gse)
adjp <- adjp$adjp[order(adjp$index),]
### Bonferroni only
adjp <- mt.rawp2adjp(gse,proc="Bonferroni")
require(multtest)
install.packages("multtest")
biocLite("multtest")
library(multtest)
### Correct p-values
adjp <- mt.rawp2adjp(gse)
adjp <- adjp$adjp[order(adjp$index),]
### Bonferroni only
adjp <- mt.rawp2adjp(gse,proc="Bonferroni")
adjp <- adjp$adjp[order(adjp$index),]
### Benjamini-Hochberg only
adjp <- mt.rawp2adjp(gse,proc="BH")
adjp <- adjp$adjp[order(adjp$index),]
### Make an histogram of the p-values
hist(adjp[,1], nclass=20)
hist(adjp[,2],nclass=20,add=TRUE,col="blue")
##################################################
### Session information
sessionInfo()
### Quit
installedPckgs <- installed.packages()[,"Package"]
### Here we define the list of desired libraries
pckgListBIOC <- c("affy", "limma", "hgu95a.db", "annotate","multtest","KEGG.db","GO.db")
### We source the biocLite.R script from the Bioconductor website
source("http://bioconductor.org/biocLite.R")
### Load the packages, or install them from Bioconductor if needed
for (pckg in pckgListBIOC) {
if (! pckg %in% installedPckgs) biocLite(pckg)
require(pckg, character.only=TRUE)
}
getwd()
setwd("~/Documents/GitHub/GeneExpressionDataAnalysis/affyData/markdown")
